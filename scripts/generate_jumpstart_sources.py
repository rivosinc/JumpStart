#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 - 2025 Rivos Inc.
#
# SPDX-License-Identifier: Apache-2.0

# Generates the jumpstart source files from the jumpstart attributes YAML file.

import argparse
import logging as log
import os
from enum import Enum

import yaml
from data_structures import ListUtils


class MemoryOp(Enum):
    LOAD = (1,)
    STORE = 2


def get_memop_of_size(memory_op_type, size_in_bytes):
    if memory_op_type == MemoryOp.LOAD:
        op = "l"
    elif memory_op_type == MemoryOp.STORE:
        op = "s"
    else:
        raise Exception(f"Invalid memory op type: {memory_op_type}")

    if size_in_bytes == 1:
        return op + "b"
    elif size_in_bytes == 2:
        return op + "h"
    elif size_in_bytes == 4:
        return op + "w"
    elif size_in_bytes == 8:
        return op + "d"
    else:
        raise Exception(f"Invalid size: {size_in_bytes} bytes")


field_type_to_size_in_bytes = {
    "uint8_t": 1,
    "uint16_t": 2,
    "uint32_t": 4,
    "uint64_t": 8,
}


class CStructField:
    """Represents a single field in a C struct."""

    def __init__(self, name, field_type, num_elements=1):
        self.name = name
        self.field_type = field_type
        self.num_elements = num_elements
        self.size_in_bytes = field_type_to_size_in_bytes[field_type]


class CStruct:
    """Represents a C struct with its fields and metadata."""

    def __init__(self, name, fields_data):
        self.name = name
        self.fields = []
        self.size_in_bytes = 0
        self.alignment = 8  # Hardcoded to 8-byte alignment
        self._parse_fields(fields_data)
        self._calculate_offsets_and_size()

    def _parse_fields(self, fields_data):
        """Parse field data from YAML into CStructField objects."""
        for field_name, field_spec in fields_data.items():
            if "," in field_spec:
                field_type, num_elements = field_spec.split(",")
                num_elements = int(num_elements.strip())
            else:
                field_type = field_spec
                num_elements = 1

            field = CStructField(field_name, field_type.strip(), num_elements)
            self.fields.append(field)

    def _calculate_offsets_and_size(self):
        """Calculate field offsets and total struct size."""
        current_offset = 0

        for field in self.fields:
            # Align field to its natural boundary
            while (current_offset % field.size_in_bytes) != 0:
                current_offset += 1

            field.offset = current_offset
            current_offset += field.size_in_bytes * field.num_elements

        # Align struct to specified boundary
        while (current_offset % self.alignment) != 0:
            current_offset += 1

        self.size_in_bytes = current_offset


class JumpStartGeneratedSource:
    def __init__(
        self,
        jumpstart_source_attributes_yaml,
        defines_file,
        data_structures_file,
        assembly_file,
        priv_modes_enabled,
    ) -> None:
        log.debug(f"Generating jumpstart source files from {jumpstart_source_attributes_yaml}")

        self.priv_modes_enabled = priv_modes_enabled

        self.attributes_data = None
        with open(jumpstart_source_attributes_yaml) as f:
            self.attributes_data = yaml.safe_load(f)
            f.close()

        self.defines_file_fd = open(defines_file, "w")
        self.data_structures_file_fd = open(data_structures_file, "w")
        self.assembly_file_fd = open(assembly_file, "w")

        # Parse C structs from YAML data
        self.c_structs = self._parse_c_structs()

    def __del__(self):
        self.defines_file_fd.close()
        self.data_structures_file_fd.close()
        self.assembly_file_fd.close()

    def _parse_c_structs(self):
        """Parse C structs from YAML data into CStruct objects."""
        c_structs = []
        for struct_name, struct_data in self.attributes_data["c_structs"].items():
            c_struct = CStruct(struct_name, struct_data["fields"])
            c_structs.append(c_struct)
        return c_structs

    def generate(self):
        self.generate_headers()

    def generate_headers(self):
        self.defines_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.defines_file_fd.write("#pragma once\n\n")
        self.data_structures_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.data_structures_file_fd.write("#pragma once\n\n")

        self.assembly_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.assembly_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.assembly_file_fd.write('#include "cpu_bits.h"\n\n')

        self.data_structures_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.data_structures_file_fd.write("#include <inttypes.h>\n")
        self.data_structures_file_fd.write("#include <stddef.h>\n\n")

    def generate_cstructs_defines(self):
        """Generate #define statements for struct sizes and field counts."""
        for c_struct in self.c_structs:
            # Generate defines for array field counts
            for field in c_struct.fields:
                if field.num_elements > 1:
                    self.defines_file_fd.write(
                        f"#define NUM_{field.name.upper()} {field.num_elements}\n"
                    )

            # Generate struct size define
            self.defines_file_fd.write(
                f"#define {c_struct.name.upper()}_STRUCT_SIZE_IN_BYTES {c_struct.size_in_bytes}\n\n"
            )

            # Generate field offset defines and getter/setter macros for thread_attributes
            if c_struct.name == "thread_attributes":
                for field in c_struct.fields:
                    self.defines_file_fd.write(
                        f"#define {c_struct.name.upper()}_{field.name.upper()}_OFFSET {field.offset}\n"
                    )
                    self.defines_file_fd.write(
                        f"#define GET_{c_struct.name.upper()}_{field.name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.LOAD, field.size_in_bytes)}   dest_reg, {c_struct.name.upper()}_{field.name.upper()}_OFFSET(tp);\n"
                    )
                    self.defines_file_fd.write(
                        f"#define SET_{c_struct.name.upper()}_{field.name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.STORE, field.size_in_bytes)}   dest_reg, {c_struct.name.upper()}_{field.name.upper()}_OFFSET(tp);\n\n"
                    )

    def generate_cstructs_data_structures(self):
        """Generate C struct definitions."""
        for c_struct in self.c_structs:
            self.data_structures_file_fd.write(f"struct {c_struct.name} {{\n")
            for field in c_struct.fields:
                if field.num_elements > 1:
                    self.data_structures_file_fd.write(
                        f"    {field.field_type} {field.name}[NUM_{field.name.upper()}];\n"
                    )
                else:
                    self.data_structures_file_fd.write(f"    {field.field_type} {field.name};\n")
            self.data_structures_file_fd.write(
                f"}} __attribute__((aligned({c_struct.alignment})));\n\n"
            )

            # Generate offsetof assertions for compile-time verification
            self._generate_offsetof_assertions(c_struct)

    def _generate_offsetof_assertions(self, c_struct):
        """Generate _Static_assert statements using offsetof() for compile-time verification."""
        for field in c_struct.fields:
            self.data_structures_file_fd.write(
                f"_Static_assert(offsetof(struct {c_struct.name}, {field.name}) == {field.offset}, "
                f'"{c_struct.name}.{field.name} offset mismatch");\n'
            )

        # Generate size assertion
        self.data_structures_file_fd.write(
            f"_Static_assert(sizeof(struct {c_struct.name}) == {c_struct.name.upper()}_STRUCT_SIZE_IN_BYTES, "
            f'"{c_struct.name} size mismatch");\n\n'
        )

    def generate_cstructs_assembly(self):
        """Generate assembly code for struct regions and getter/setter functions."""
        for c_struct in self.c_structs:
            # Generate assembly regions
            self.assembly_file_fd.write('.section .jumpstart.cpu.c_structs.mmode, "aw"\n\n')
            self.assembly_file_fd.write(f".global {c_struct.name}_region\n")
            self.assembly_file_fd.write(f"{c_struct.name}_region:\n")
            for i in range(self.attributes_data["max_num_cpus_supported"]):
                self.assembly_file_fd.write(f".global {c_struct.name}_region_cpu_{i}\n")
                self.assembly_file_fd.write(f"{c_struct.name}_region_cpu_{i}:\n")
                self.assembly_file_fd.write(f"  .zero {c_struct.size_in_bytes}\n")
            self.assembly_file_fd.write(f".global {c_struct.name}_region_end\n")
            self.assembly_file_fd.write(f"{c_struct.name}_region_end:\n\n")

            # Generate getter/setter functions for thread_attributes
            if c_struct.name == "thread_attributes":
                modes = ListUtils.intersection(["smode", "mmode"], self.priv_modes_enabled)
                for field in c_struct.fields:
                    for mode in modes:
                        self.assembly_file_fd.write(f'.section .jumpstart.cpu.text.{mode}, "ax"\n')
                        getter_method = f"get_{c_struct.name}_{field.name}_from_{mode}"
                        self.assembly_file_fd.write(f".global {getter_method}\n")
                        self.assembly_file_fd.write(f"{getter_method}:\n")
                        self.assembly_file_fd.write(
                            f"    GET_{c_struct.name.upper()}_{field.name.upper()}(a0)\n"
                        )
                        self.assembly_file_fd.write("    ret\n\n")

                        self.assembly_file_fd.write(
                            f".global set_{c_struct.name}_{field.name}_from_{mode}\n"
                        )
                        self.assembly_file_fd.write(
                            f"set_{c_struct.name}_{field.name}_from_{mode}:\n"
                        )
                        self.assembly_file_fd.write(
                            f"    SET_{c_struct.name.upper()}_{field.name.upper()}(a0)\n"
                        )
                        self.assembly_file_fd.write("    ret\n\n")

        # Validate total size
        total_size_of_c_structs = sum(c_struct.size_in_bytes for c_struct in self.c_structs)
        max_allowed_size_of_c_structs = (
            self.attributes_data["jumpstart_mmode"]["c_structs"]["num_pages_per_cpu"]
            * self.attributes_data["max_num_cpus_supported"]
            * self.attributes_data["jumpstart_mmode"]["c_structs"]["page_size"]
        )

        if (
            total_size_of_c_structs * self.attributes_data["max_num_cpus_supported"]
            > max_allowed_size_of_c_structs
        ):
            raise Exception(
                f"Total size of C structs ({total_size_of_c_structs}) exceeds maximum size allocated for C structs {max_allowed_size_of_c_structs}"
            )


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--jumpstart_source_attributes_yaml",
        help="YAML containing the jumpstart attributes.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--priv_modes_enabled",
        help=".",
        required=True,
        nargs="+",
        default=None,
    )
    parser.add_argument(
        "--defines_file", help="Header file containing the defines.", required=True, type=str
    )
    parser.add_argument(
        "--data_structures_file",
        help="Header file containing the c structures.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--assembly_file", help="Assembly file containing functions.", required=True, type=str
    )
    parser.add_argument(
        "-v", "--verbose", help="Verbose output.", action="store_true", default=False
    )
    args = parser.parse_args()

    if args.verbose:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.DEBUG)
    else:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.INFO)

    source_generator = JumpStartGeneratedSource(
        args.jumpstart_source_attributes_yaml,
        args.defines_file,
        args.data_structures_file,
        args.assembly_file,
        args.priv_modes_enabled,
    )

    source_generator.generate()


if __name__ == "__main__":
    main()
