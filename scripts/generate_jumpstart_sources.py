#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 - 2025 Rivos Inc.
#
# SPDX-License-Identifier: Apache-2.0

# Generates the jumpstart source files from the jumpstart attributes YAML file.

import argparse
import logging as log
import os
from enum import Enum

import yaml
from data_structures import ListUtils


class MemoryOp(Enum):
    LOAD = (1,)
    STORE = 2


def get_memop_of_size(memory_op_type, size_in_bytes):
    if memory_op_type == MemoryOp.LOAD:
        op = "l"
    elif memory_op_type == MemoryOp.STORE:
        op = "s"
    else:
        raise Exception(f"Invalid memory op type: {memory_op_type}")

    if size_in_bytes == 1:
        return op + "b"
    elif size_in_bytes == 2:
        return op + "h"
    elif size_in_bytes == 4:
        return op + "w"
    elif size_in_bytes == 8:
        return op + "d"
    else:
        raise Exception(f"Invalid size: {size_in_bytes} bytes")


field_type_to_size_in_bytes = {
    "uint8_t": 1,
    "uint16_t": 2,
    "uint32_t": 4,
    "uint64_t": 8,
}


class JumpStartGeneratedSource:
    def __init__(
        self,
        jumpstart_source_attributes_yaml,
        defines_file,
        data_structures_file,
        assembly_file,
        priv_modes_enabled,
    ) -> None:
        log.debug(f"Generating jumpstart source files from {jumpstart_source_attributes_yaml}")

        self.priv_modes_enabled = priv_modes_enabled

        self.attributes_data = None
        with open(jumpstart_source_attributes_yaml) as f:
            self.attributes_data = yaml.safe_load(f)
            f.close()

        self.defines_file_fd = open(defines_file, "w")
        self.data_structures_file_fd = open(data_structures_file, "w")
        self.assembly_file_fd = open(assembly_file, "w")

    def __del__(self):
        self.defines_file_fd.close()
        self.data_structures_file_fd.close()
        self.assembly_file_fd.close()

    def generate(self):
        self.generate_headers()

        self.generate_c_structs()

    def generate_headers(self):
        self.defines_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.defines_file_fd.write("#pragma once\n\n")
        self.data_structures_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.data_structures_file_fd.write("#pragma once\n\n")

        self.assembly_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.assembly_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.assembly_file_fd.write('#include "cpu_bits.h"\n\n')

        self.data_structures_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.data_structures_file_fd.write("#include <inttypes.h>\n\n")

    def generate_c_structs(self):
        total_size_of_c_structs = 0

        for c_struct in self.attributes_data["c_structs"]:
            c_struct_fields = self.attributes_data["c_structs"][c_struct]["fields"]
            current_offset = 0

            self.data_structures_file_fd.write(f"struct {c_struct} {{\n")
            for field_name in c_struct_fields:
                num_field_elements = 1
                if len(c_struct_fields[field_name].split(",")) > 1:
                    field_type = c_struct_fields[field_name].split(",")[0]
                    num_field_elements = int(c_struct_fields[field_name].split(",")[1])
                    self.defines_file_fd.write(
                        f"#define NUM_{field_name.upper()} {num_field_elements}\n"
                    )
                else:
                    field_type = c_struct_fields[field_name]

                field_size_in_bytes = field_type_to_size_in_bytes[field_type]
                if num_field_elements > 1:
                    self.data_structures_file_fd.write(
                        f"    {field_type} {field_name}[NUM_{field_name.upper()}];\n"
                    )
                else:
                    self.data_structures_file_fd.write(f"    {field_type} {field_name};\n")

                # Take care of the padding that the compiler will add.
                while (current_offset % field_size_in_bytes) != 0:
                    current_offset += 1

                if c_struct == "thread_attributes":
                    self.generate_getter_and_setter_methods_for_field(
                        c_struct,
                        field_name,
                        field_size_in_bytes,
                        current_offset,
                    )

                current_offset += field_size_in_bytes * num_field_elements

            self.data_structures_file_fd.write("};\n\n")

            # Align the end of the struct to 8 bytes.
            while (current_offset % 8) != 0:
                current_offset += 1
            self.defines_file_fd.write(
                f"#define {c_struct.upper()}_STRUCT_SIZE_IN_BYTES {current_offset}\n\n"
            )

            self.assembly_file_fd.write('.section .jumpstart.cpu.c_structs.mmode, "aw"\n\n')
            self.assembly_file_fd.write(f".global {c_struct}_region\n")
            self.assembly_file_fd.write(f"{c_struct}_region:\n")
            for i in range(self.attributes_data["max_num_cpus_supported"]):
                self.assembly_file_fd.write(f".global {c_struct}_region_cpu_{i}\n")
                self.assembly_file_fd.write(f"{c_struct}_region_cpu_{i}:\n")
                self.assembly_file_fd.write(f"  .zero {current_offset}\n")
            self.assembly_file_fd.write(f".global {c_struct}_region_end\n")
            self.assembly_file_fd.write(f"{c_struct}_region_end:\n\n")

            total_size_of_c_structs += current_offset

        max_allowed_size_of_c_structs = (
            self.attributes_data["jumpstart_mmode"]["c_structs"]["num_pages_per_cpu"]
            * self.attributes_data["max_num_cpus_supported"]
            * self.attributes_data["jumpstart_mmode"]["c_structs"]["page_size"]
        )

        if (
            total_size_of_c_structs * self.attributes_data["max_num_cpus_supported"]
            > max_allowed_size_of_c_structs
        ):
            raise Exception(
                f"Total size of C structs ({total_size_of_c_structs}) exceeds maximum size allocated for C structs {max_allowed_size_of_c_structs}"
            )

    def generate_getter_and_setter_methods_for_field(
        self,
        c_struct,
        field_name,
        field_size_in_bytes,
        field_offset_in_struct,
    ):
        self.defines_file_fd.write(
            f"#define {c_struct.upper()}_{field_name.upper()}_OFFSET {field_offset_in_struct}\n"
        )

        self.defines_file_fd.write(
            f"#define GET_{c_struct.upper()}_{field_name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.LOAD, field_size_in_bytes)}   dest_reg, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp);\n"
        )
        self.defines_file_fd.write(
            f"#define SET_{c_struct.upper()}_{field_name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.STORE, field_size_in_bytes)}   dest_reg, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp);\n\n"
        )

        modes = ListUtils.intersection(["smode", "mmode"], self.priv_modes_enabled)
        for mode in modes:
            self.assembly_file_fd.write(f'.section .jumpstart.cpu.text.{mode}, "ax"\n')
            getter_method = f"get_{c_struct}_{field_name}_from_{mode}"
            self.assembly_file_fd.write(f".global {getter_method}\n")
            self.assembly_file_fd.write(f"{getter_method}:\n")
            self.assembly_file_fd.write(f"    GET_{c_struct.upper()}_{field_name.upper()}(a0)\n")
            self.assembly_file_fd.write("    ret\n\n")

            self.assembly_file_fd.write(f".global set_{c_struct}_{field_name}_from_{mode}\n")
            self.assembly_file_fd.write(f"set_{c_struct}_{field_name}_from_{mode}:\n")
            self.assembly_file_fd.write(f"    SET_{c_struct.upper()}_{field_name.upper()}(a0)\n")
            self.assembly_file_fd.write("    ret\n\n")


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--jumpstart_source_attributes_yaml",
        help="YAML containing the jumpstart attributes.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--priv_modes_enabled",
        help=".",
        required=True,
        nargs="+",
        default=None,
    )
    parser.add_argument(
        "--defines_file", help="Header file containing the defines.", required=True, type=str
    )
    parser.add_argument(
        "--data_structures_file",
        help="Header file containing the c structures.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--assembly_file", help="Assembly file containing functions.", required=True, type=str
    )
    parser.add_argument(
        "-v", "--verbose", help="Verbose output.", action="store_true", default=False
    )
    args = parser.parse_args()

    if args.verbose:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.DEBUG)
    else:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.INFO)

    source_generator = JumpStartGeneratedSource(
        args.jumpstart_source_attributes_yaml,
        args.defines_file,
        args.data_structures_file,
        args.assembly_file,
        args.priv_modes_enabled,
    )

    source_generator.generate()


if __name__ == "__main__":
    main()
