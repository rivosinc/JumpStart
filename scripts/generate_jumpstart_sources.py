#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 - 2024 Rivos Inc.
#
# SPDX-License-Identifier: Apache-2.0

# Generates the jumpstart source files from the jumpstart attributes YAML file.

import argparse
import logging as log
import os
import sys
from enum import Enum

import yaml
from utils.lib import DictUtils, ListUtils


class MemoryOp(Enum):
    LOAD = (1,)
    STORE = 2


def get_memop_of_size(memory_op_type, size_in_bytes):
    if memory_op_type == MemoryOp.LOAD:
        op = "l"
    elif memory_op_type == MemoryOp.STORE:
        op = "s"
    else:
        raise Exception(f"Invalid memory op type: {memory_op_type}")

    if size_in_bytes == 1:
        return op + "b"
    elif size_in_bytes == 2:
        return op + "h"
    elif size_in_bytes == 4:
        return op + "w"
    elif size_in_bytes == 8:
        return op + "d"
    else:
        raise Exception(f"Invalid size: {size_in_bytes} bytes")


field_type_to_size_in_bytes = {
    "uint8_t": 1,
    "uint16_t": 2,
    "uint32_t": 4,
    "uint64_t": 8,
}


class JumpStartGeneratedSource:
    def __init__(
        self,
        jumpstart_source_attributes_yaml,
        override_jumpstart_source_attributes,
        defines_file,
        data_structures_file,
        assembly_file,
        priv_modes_enabled,
    ) -> None:
        log.debug(f"Generating jumpstart source files from {jumpstart_source_attributes_yaml}")

        self.priv_modes_enabled = priv_modes_enabled

        self.attributes_data = None
        with open(jumpstart_source_attributes_yaml) as f:
            self.attributes_data = yaml.safe_load(f)
            f.close()

        if override_jumpstart_source_attributes:
            # Override the default jumpstart source attribute values with the values
            # specified on the command line.
            DictUtils.override_dict(
                self.attributes_data,
                DictUtils.create_dict(override_jumpstart_source_attributes),
            )

        self.defines_file_fd = open(defines_file, "w")
        self.data_structures_file_fd = open(data_structures_file, "w")
        self.assembly_file_fd = open(assembly_file, "w")

    def __del__(self):
        self.defines_file_fd.close()
        self.data_structures_file_fd.close()
        self.assembly_file_fd.close()

    def generate(self):
        self.generate_headers()

        self.generate_c_structs()

        self.generate_stack()

        self.generate_defines()

        self.generate_reg_context_save_restore_code()

        self.generate_thread_attributes_setup_code()

    def generate_headers(self):
        self.defines_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.defines_file_fd.write("#pragma once\n\n")
        self.data_structures_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.data_structures_file_fd.write("#pragma once\n\n")

        self.assembly_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.assembly_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.assembly_file_fd.write('#include "cpu_bits.h"\n\n')

        self.defines_file_fd.write(
            f"#define MAX_NUM_HARTS_SUPPORTED {self.attributes_data['max_num_harts_supported']}\n\n"
        )

        self.data_structures_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.data_structures_file_fd.write("#include <inttypes.h>\n\n")

    def generate_c_structs(self):
        total_size_of_c_structs = 0

        for c_struct in self.attributes_data["c_structs"]:
            c_struct_fields = self.attributes_data["c_structs"][c_struct]["fields"]
            current_offset = 0

            self.data_structures_file_fd.write(f"struct {c_struct} {{\n")
            for field_name in c_struct_fields:
                num_field_elements = 1
                if len(c_struct_fields[field_name].split(",")) > 1:
                    field_type = c_struct_fields[field_name].split(",")[0]
                    num_field_elements = int(c_struct_fields[field_name].split(",")[1])
                    self.defines_file_fd.write(
                        f"#define NUM_{field_name.upper()} {num_field_elements}\n"
                    )
                else:
                    field_type = c_struct_fields[field_name]

                field_size_in_bytes = field_type_to_size_in_bytes[field_type]
                if num_field_elements > 1:
                    self.data_structures_file_fd.write(
                        f"    {field_type} {field_name}[NUM_{field_name.upper()}];\n"
                    )
                else:
                    self.data_structures_file_fd.write(f"    {field_type} {field_name};\n")

                # Take care of the padding that the compiler will add.
                while (current_offset % field_size_in_bytes) != 0:
                    current_offset += 1

                if c_struct == "thread_attributes":
                    self.generate_getter_and_setter_methods_for_field(
                        c_struct,
                        field_name,
                        field_size_in_bytes,
                        current_offset,
                    )

                current_offset += field_size_in_bytes * num_field_elements

            self.data_structures_file_fd.write("};\n\n")

            # Align the end of the struct to 8 bytes.
            while (current_offset % 8) != 0:
                current_offset += 1
            self.defines_file_fd.write(
                f"#define {c_struct.upper()}_STRUCT_SIZE_IN_BYTES {current_offset}\n\n"
            )

            self.assembly_file_fd.write('.section .jumpstart.c_structs.smode, "aw"\n\n')
            self.assembly_file_fd.write(f".global {c_struct}_region\n")
            self.assembly_file_fd.write(f"{c_struct}_region:\n")
            for i in range(self.attributes_data["max_num_harts_supported"]):
                self.assembly_file_fd.write(f".global {c_struct}_region_hart_{i}\n")
                self.assembly_file_fd.write(f"{c_struct}_region_hart_{i}:\n")
                self.assembly_file_fd.write(f"  .zero {current_offset}\n")
            self.assembly_file_fd.write(f".global {c_struct}_region_end\n")
            self.assembly_file_fd.write(f"{c_struct}_region_end:\n\n")

            total_size_of_c_structs += current_offset

        max_allowed_size_of_c_structs = (
            self.attributes_data["jumpstart_smode"]["c_structs"]["num_pages"]
            * self.attributes_data["jumpstart_smode"]["c_structs"]["page_size"]
        )

        if (
            total_size_of_c_structs * self.attributes_data["max_num_harts_supported"]
            > max_allowed_size_of_c_structs
        ):
            log.error(
                f"Total size of C structs ({total_size_of_c_structs}) exceeds maximum size allocated for C structs {max_allowed_size_of_c_structs}"
            )
            sys.exit(1)

    def generate_stack(self):
        stack_types = ["smode", "umode"]
        for stack_type in stack_types:
            # Make sure we can equally distribute the number of total stack pages
            # among the harts.
            assert (
                self.attributes_data[f"jumpstart_{stack_type}"]["stack"]["num_pages"]
                % self.attributes_data["max_num_harts_supported"]
                == 0
            )
            num_pages_per_hart_for_stack = int(
                self.attributes_data[f"jumpstart_{stack_type}"]["stack"]["num_pages"]
                / self.attributes_data["max_num_harts_supported"]
            )
            stack_page_size = self.attributes_data[f"jumpstart_{stack_type}"]["stack"]["page_size"]

            self.defines_file_fd.write(
                f"#define NUM_PAGES_PER_HART_FOR_{stack_type.upper()}_STACK {num_pages_per_hart_for_stack}\n\n"
            )

            self.defines_file_fd.write(
                f"#define {stack_type.upper()}_STACK_PAGE_SIZE {stack_page_size}\n\n"
            )

            self.assembly_file_fd.write(f'.section .jumpstart.stack.{stack_type}, "aw"\n')
            self.assembly_file_fd.write(".align 12\n")
            self.assembly_file_fd.write(f".global {stack_type}_stack_top\n")
            self.assembly_file_fd.write(f"{stack_type}_stack_top:\n")
            for i in range(self.attributes_data["max_num_harts_supported"]):
                self.assembly_file_fd.write(f".global {stack_type}_stack_top_hart_{i}\n")
                self.assembly_file_fd.write(f"{stack_type}_stack_top_hart_{i}:\n")
                self.assembly_file_fd.write(
                    f"  .zero {num_pages_per_hart_for_stack * stack_page_size}\n"
                )
            self.assembly_file_fd.write(f".global {stack_type}_stack_bottom\n")
            self.assembly_file_fd.write(f"{stack_type}_stack_bottom:\n\n")

    def generate_defines(self):
        for define_name in self.attributes_data["defines"]:
            self.defines_file_fd.write(
                f"#define {define_name} {self.attributes_data['defines'][define_name]}\n"
            )

        self.defines_file_fd.write("\n")
        current_syscall_number = 0
        for syscall_name in self.attributes_data["syscall_numbers"]:
            self.defines_file_fd.write(f"#define {syscall_name} {current_syscall_number}\n")
            current_syscall_number += 1

    def generate_getter_and_setter_methods_for_field(
        self,
        c_struct,
        field_name,
        field_size_in_bytes,
        field_offset_in_struct,
    ):
        self.defines_file_fd.write(
            f"#define {c_struct.upper()}_{field_name.upper()}_OFFSET {field_offset_in_struct}\n"
        )

        self.defines_file_fd.write(
            f"#define GET_{c_struct.upper()}_{field_name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.LOAD, field_size_in_bytes)}   dest_reg, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp);\n"
        )
        self.defines_file_fd.write(
            f"#define SET_{c_struct.upper()}_{field_name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.STORE, field_size_in_bytes)}   dest_reg, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp);\n\n"
        )

        modes = ListUtils.intersection(["smode", "mmode"], self.priv_modes_enabled)
        for mode in modes:
            self.assembly_file_fd.write(f'.section .jumpstart.text.{mode}, "ax"\n')
            getter_method = f"get_{c_struct}_{field_name}_from_{mode}"
            self.assembly_file_fd.write(f".global {getter_method}\n")
            self.assembly_file_fd.write(f"{getter_method}:\n")
            self.assembly_file_fd.write(f"    GET_{c_struct.upper()}_{field_name.upper()}(a0)\n")
            self.assembly_file_fd.write("    ret\n\n")

            self.assembly_file_fd.write(f".global set_{c_struct}_{field_name}_from_{mode}\n")
            self.assembly_file_fd.write(f"set_{c_struct}_{field_name}_from_{mode}:\n")
            self.assembly_file_fd.write(f"    SET_{c_struct.upper()}_{field_name.upper()}(a0)\n")
            self.assembly_file_fd.write("    ret\n\n")

    def generate_thread_attributes_setup_code(self):
        modes = ListUtils.intersection(["smode", "mmode"], self.priv_modes_enabled)
        mode_encodings = {"smode": "PRV_S", "mmode": "PRV_M"}
        for mode in modes:
            self.assembly_file_fd.write(f'.section .jumpstart.text.{mode}, "ax"\n')
            self.assembly_file_fd.write("# Inputs:\n")
            self.assembly_file_fd.write("#   a0: hart id\n")
            self.assembly_file_fd.write(f".global setup_thread_attributes_from_{mode}\n")
            self.assembly_file_fd.write(f"setup_thread_attributes_from_{mode}:\n")
            self.assembly_file_fd.write("  li t1, MAX_NUM_HARTS_SUPPORTED\n")
            self.assembly_file_fd.write(f"  bgeu a0, t1, jumpstart_{mode}_fail\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li  t2, THREAD_ATTRIBUTES_STRUCT_SIZE_IN_BYTES\n")
            self.assembly_file_fd.write("  mul t2, a0, t2\n")
            self.assembly_file_fd.write("  la  t1, thread_attributes_region\n")
            self.assembly_file_fd.write("  add tp, t1, t2\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_HART_ID(a0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li t0, TRAP_OVERRIDE_ATTRIBUTES_STRUCT_SIZE_IN_BYTES\n")
            self.assembly_file_fd.write("  mul t0, a0, t0\n")
            self.assembly_file_fd.write("  la t1, trap_override_attributes_region\n")
            self.assembly_file_fd.write("  add t0, t1, t0\n")
            self.assembly_file_fd.write(
                "  SET_THREAD_ATTRIBUTES_TRAP_OVERRIDE_STRUCT_ADDRESS(t0)\n"
            )
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li t0, REG_CONTEXT_SAVE_REGION_SIZE_IN_BYTES\n")
            self.assembly_file_fd.write("  mul t0, a0, t0\n")
            self.assembly_file_fd.write("\n")
            if "mmode" in modes:
                self.assembly_file_fd.write("  la t1, mmode_reg_context_save_region\n")
                self.assembly_file_fd.write("  add t1, t1, t0\n")
                self.assembly_file_fd.write("  la t2, mmode_reg_context_save_region_end\n")
                self.assembly_file_fd.write(f"  bgeu t1, t2, jumpstart_{mode}_fail\n")
                self.assembly_file_fd.write(
                    "  SET_THREAD_ATTRIBUTES_MMODE_REG_CONTEXT_SAVE_REGION_ADDRESS(t1)\n"
                )
                self.assembly_file_fd.write("\n")
                self.assembly_file_fd.write(
                    "  la t1, lower_mode_in_mmode_reg_context_save_region\n"
                )
                self.assembly_file_fd.write("  add t1, t1, t0\n")
                self.assembly_file_fd.write(
                    "  la t2, lower_mode_in_mmode_reg_context_save_region_end\n"
                )
                self.assembly_file_fd.write(f"  bgeu t1, t2, jumpstart_{mode}_fail\n")
                self.assembly_file_fd.write(
                    "  SET_THREAD_ATTRIBUTES_LOWER_MODE_IN_MMODE_REG_CONTEXT_SAVE_REGION_ADDRESS(t1)\n"
                )
                self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  la t1, smode_reg_context_save_region\n")
            self.assembly_file_fd.write("  add t1, t1, t0\n")
            self.assembly_file_fd.write("  la t2, smode_reg_context_save_region_end\n")
            self.assembly_file_fd.write(f"  bgeu t1, t2, jumpstart_{mode}_fail\n")
            self.assembly_file_fd.write(
                "  SET_THREAD_ATTRIBUTES_SMODE_REG_CONTEXT_SAVE_REGION_ADDRESS(t1)\n"
            )
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  la t1, umode_reg_context_save_region\n")
            self.assembly_file_fd.write("  add t1, t1, t0\n")
            self.assembly_file_fd.write("  la t2, umode_reg_context_save_region_end\n")
            self.assembly_file_fd.write(f"  bgeu t1, t2, jumpstart_{mode}_fail\n")
            self.assembly_file_fd.write(
                "  SET_THREAD_ATTRIBUTES_UMODE_REG_CONTEXT_SAVE_REGION_ADDRESS(t1)\n"
            )
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li  t0, 0\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_SMODE_SETUP_DONE(t0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write(f"  li  t0, {mode_encodings[mode]}\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_CURRENT_MODE(t0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li  t0, THREAD_ATTRIBUTES_BOOKEND_MAGIC_NUMBER_VALUE\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_BOOKEND_MAGIC_NUMBER(t0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  ret\n")

    def generate_reg_context_save_restore_code(self):
        assert (
            self.attributes_data["reg_context_to_save_across_modes"]["temp_register"]
            not in self.attributes_data["reg_context_to_save_across_modes"]["registers"]["gprs"]
        )

        num_registers = 0
        for reg_type in self.attributes_data["reg_context_to_save_across_modes"]["registers"]:
            reg_names = self.attributes_data["reg_context_to_save_across_modes"]["registers"][
                reg_type
            ]
            for reg_name in reg_names:
                self.defines_file_fd.write(
                    f"#define {reg_name.upper()}_OFFSET_IN_SAVE_REGION ({num_registers} * 8)\n"
                )
                num_registers += 1

        temp_reg_name = self.attributes_data["reg_context_to_save_across_modes"]["temp_register"]

        self.defines_file_fd.write(
            f"\n#define REG_CONTEXT_SAVE_REGION_SIZE_IN_BYTES ({num_registers} * 8)\n"
        )

        self.defines_file_fd.write("\n#define SAVE_ALL_GPRS   ;")
        for gpr_name in self.attributes_data["reg_context_to_save_across_modes"]["registers"][
            "gprs"
        ]:
            self.defines_file_fd.write(
                f"\\\n  sd {gpr_name}, {gpr_name.upper()}_OFFSET_IN_SAVE_REGION({temp_reg_name})   ;"
            )
        self.defines_file_fd.write("\n\n")

        self.defines_file_fd.write("\n#define RESTORE_ALL_GPRS   ;")
        for gpr_name in self.attributes_data["reg_context_to_save_across_modes"]["registers"][
            "gprs"
        ]:
            self.defines_file_fd.write(
                f"\\\n  ld {gpr_name}, {gpr_name.upper()}_OFFSET_IN_SAVE_REGION({temp_reg_name})   ;"
            )
        self.defines_file_fd.write("\n\n")

        self.assembly_file_fd.write('\n\n.section .jumpstart.data.smode, "aw"\n')
        modes = ListUtils.intersection(["mmode", "smode", "umode"], self.priv_modes_enabled)
        if "mmode" in modes:
            modes += ["lower_mode_in_mmode"]
        self.assembly_file_fd.write(
            f"\n# {modes} context saved registers:\n# {self.attributes_data['reg_context_to_save_across_modes']['registers']}\n"
        )
        for mode in modes:
            self.assembly_file_fd.write(f".global {mode}_reg_context_save_region\n")
            self.assembly_file_fd.write(f"{mode}_reg_context_save_region:\n")
            for i in range(self.attributes_data["max_num_harts_supported"]):
                self.assembly_file_fd.write(
                    f"  # save area for hart {i}'s {num_registers} registers\n"
                )
                self.assembly_file_fd.write(f"  .zero {num_registers * 8}\n\n")
            self.assembly_file_fd.write(f".global {mode}_reg_context_save_region_end\n")
            self.assembly_file_fd.write(f"{mode}_reg_context_save_region_end:\n\n")


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--jumpstart_source_attributes_yaml",
        help="YAML containing the jumpstart attributes.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--override_jumpstart_source_attributes",
        help="Overrides the JumpStart source attributes.",
        required=False,
        nargs="+",
        default=None,
    )
    parser.add_argument(
        "--priv_modes_enabled",
        help=".",
        required=True,
        nargs="+",
        default=None,
    )
    parser.add_argument(
        "--defines_file", help="Header file containing the defines.", required=True, type=str
    )
    parser.add_argument(
        "--data_structures_file",
        help="Header file containing the c structures.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--assembly_file", help="Assembly file containing functions.", required=True, type=str
    )
    parser.add_argument(
        "-v", "--verbose", help="Verbose output.", action="store_true", default=False
    )
    args = parser.parse_args()

    if args.verbose:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.DEBUG)
    else:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.INFO)

    source_generator = JumpStartGeneratedSource(
        args.jumpstart_source_attributes_yaml,
        args.override_jumpstart_source_attributes,
        args.defines_file,
        args.data_structures_file,
        args.assembly_file,
        args.priv_modes_enabled,
    )

    source_generator.generate()


if __name__ == "__main__":
    main()
