#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 - 2025 Rivos Inc.
#
# SPDX-License-Identifier: Apache-2.0

# Generates the jumpstart source files from the jumpstart attributes YAML file.

import argparse
import logging as log
import os
import sys
from enum import Enum

import yaml
from data_structures import ListUtils


class MemoryOp(Enum):
    LOAD = (1,)
    STORE = 2


def get_memop_of_size(memory_op_type, size_in_bytes):
    if memory_op_type == MemoryOp.LOAD:
        op = "l"
    elif memory_op_type == MemoryOp.STORE:
        op = "s"
    else:
        raise Exception(f"Invalid memory op type: {memory_op_type}")

    if size_in_bytes == 1:
        return op + "b"
    elif size_in_bytes == 2:
        return op + "h"
    elif size_in_bytes == 4:
        return op + "w"
    elif size_in_bytes == 8:
        return op + "d"
    else:
        raise Exception(f"Invalid size: {size_in_bytes} bytes")


field_type_to_size_in_bytes = {
    "uint8_t": 1,
    "uint16_t": 2,
    "uint32_t": 4,
    "uint64_t": 8,
}


class JumpStartGeneratedSource:
    def __init__(
        self,
        jumpstart_source_attributes_yaml,
        defines_file,
        data_structures_file,
        assembly_file,
        priv_modes_enabled,
    ) -> None:
        log.debug(f"Generating jumpstart source files from {jumpstart_source_attributes_yaml}")

        self.priv_modes_enabled = priv_modes_enabled

        self.attributes_data = None
        with open(jumpstart_source_attributes_yaml) as f:
            self.attributes_data = yaml.safe_load(f)
            f.close()

        self.defines_file_fd = open(defines_file, "w")
        self.data_structures_file_fd = open(data_structures_file, "w")
        self.assembly_file_fd = open(assembly_file, "w")

    def __del__(self):
        self.defines_file_fd.close()
        self.data_structures_file_fd.close()
        self.assembly_file_fd.close()

    def generate(self):
        self.generate_headers()

        self.generate_c_structs()

        self.generate_stack()

        self.generate_defines()

        self.generate_reg_context_save_restore_code()

        self.generate_thread_attributes_setup_code()

    def generate_headers(self):
        self.defines_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.defines_file_fd.write("#pragma once\n\n")
        self.data_structures_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.data_structures_file_fd.write("#pragma once\n\n")

        self.assembly_file_fd.write(
            f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
        )
        self.assembly_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.assembly_file_fd.write('#include "cpu_bits.h"\n\n')

        self.defines_file_fd.write(
            f"#define MAX_NUM_CPUS_SUPPORTED {self.attributes_data['max_num_cpus_supported']}\n\n"
        )

        self.data_structures_file_fd.write('#include "jumpstart_defines.h"\n\n')
        self.data_structures_file_fd.write("#include <inttypes.h>\n\n")

    def generate_c_structs(self):
        total_size_of_c_structs = 0

        for c_struct in self.attributes_data["c_structs"]:
            c_struct_fields = self.attributes_data["c_structs"][c_struct]["fields"]
            current_offset = 0

            self.data_structures_file_fd.write(f"struct {c_struct} {{\n")
            for field_name in c_struct_fields:
                num_field_elements = 1
                if len(c_struct_fields[field_name].split(",")) > 1:
                    field_type = c_struct_fields[field_name].split(",")[0]
                    num_field_elements = int(c_struct_fields[field_name].split(",")[1])
                    self.defines_file_fd.write(
                        f"#define NUM_{field_name.upper()} {num_field_elements}\n"
                    )
                else:
                    field_type = c_struct_fields[field_name]

                field_size_in_bytes = field_type_to_size_in_bytes[field_type]
                if num_field_elements > 1:
                    self.data_structures_file_fd.write(
                        f"    {field_type} {field_name}[NUM_{field_name.upper()}];\n"
                    )
                else:
                    self.data_structures_file_fd.write(f"    {field_type} {field_name};\n")

                # Take care of the padding that the compiler will add.
                while (current_offset % field_size_in_bytes) != 0:
                    current_offset += 1

                if c_struct == "thread_attributes":
                    self.generate_getter_and_setter_methods_for_field(
                        c_struct,
                        field_name,
                        field_size_in_bytes,
                        current_offset,
                    )

                current_offset += field_size_in_bytes * num_field_elements

            self.data_structures_file_fd.write("};\n\n")

            # Align the end of the struct to 8 bytes.
            while (current_offset % 8) != 0:
                current_offset += 1
            self.defines_file_fd.write(
                f"#define {c_struct.upper()}_STRUCT_SIZE_IN_BYTES {current_offset}\n\n"
            )

            self.assembly_file_fd.write('.section .jumpstart.cpu.c_structs.mmode, "aw"\n\n')
            self.assembly_file_fd.write(f".global {c_struct}_region\n")
            self.assembly_file_fd.write(f"{c_struct}_region:\n")
            for i in range(self.attributes_data["max_num_cpus_supported"]):
                self.assembly_file_fd.write(f".global {c_struct}_region_cpu_{i}\n")
                self.assembly_file_fd.write(f"{c_struct}_region_cpu_{i}:\n")
                self.assembly_file_fd.write(f"  .zero {current_offset}\n")
            self.assembly_file_fd.write(f".global {c_struct}_region_end\n")
            self.assembly_file_fd.write(f"{c_struct}_region_end:\n\n")

            total_size_of_c_structs += current_offset

        max_allowed_size_of_c_structs = (
            self.attributes_data["jumpstart_mmode"]["c_structs"]["num_pages"]
            * self.attributes_data["jumpstart_mmode"]["c_structs"]["page_size"]
        )

        if (
            total_size_of_c_structs * self.attributes_data["max_num_cpus_supported"]
            > max_allowed_size_of_c_structs
        ):
            log.error(
                f"Total size of C structs ({total_size_of_c_structs}) exceeds maximum size allocated for C structs {max_allowed_size_of_c_structs}"
            )
            sys.exit(1)

    def generate_stack(self):
        # This is a bit of a mess. Both mmode and smode share the same stack.
        # We've named this stack "privileged" so we need to map the stack
        # name to the mode.
        stack_types = ListUtils.intersection(["umode"], self.priv_modes_enabled)
        stack_types.append("privileged")
        stack_types_to_priv_mode_map = {"umode": "umode", "privileged": "mmode"}

        for stack_type in stack_types:
            # Make sure we can equally distribute the number of total stack pages
            # among the cpus.
            assert (
                self.attributes_data[f"jumpstart_{stack_types_to_priv_mode_map[stack_type]}"][
                    "stack"
                ]["num_pages"]
                % self.attributes_data["max_num_cpus_supported"]
                == 0
            )
            num_pages_per_cpu_for_stack = int(
                self.attributes_data[f"jumpstart_{stack_types_to_priv_mode_map[stack_type]}"][
                    "stack"
                ]["num_pages"]
                / self.attributes_data["max_num_cpus_supported"]
            )
            stack_page_size = self.attributes_data[
                f"jumpstart_{stack_types_to_priv_mode_map[stack_type]}"
            ]["stack"]["page_size"]

            self.defines_file_fd.write(
                f"#define NUM_PAGES_PER_CPU_FOR_{stack_type.upper()}_STACK {num_pages_per_cpu_for_stack}\n\n"
            )

            self.defines_file_fd.write(
                f"#define {stack_type.upper()}_STACK_PAGE_SIZE {stack_page_size}\n\n"
            )

        for stack_type in stack_types:
            self.assembly_file_fd.write(f'.section .jumpstart.cpu.stack.{stack_type}, "aw"\n')
            self.assembly_file_fd.write(".align 12\n")
            self.assembly_file_fd.write(f".global {stack_type}_stack_top\n")
            self.assembly_file_fd.write(f"{stack_type}_stack_top:\n")
            for i in range(self.attributes_data["max_num_cpus_supported"]):
                self.assembly_file_fd.write(f".global {stack_type}_stack_top_cpu_{i}\n")
                self.assembly_file_fd.write(f"{stack_type}_stack_top_cpu_{i}:\n")
                self.assembly_file_fd.write(
                    f"  .zero {num_pages_per_cpu_for_stack * stack_page_size}\n"
                )
            self.assembly_file_fd.write(f".global {stack_type}_stack_bottom\n")
            self.assembly_file_fd.write(f"{stack_type}_stack_bottom:\n\n")

    def generate_defines(self):
        for define_name in self.attributes_data["defines"]:
            self.defines_file_fd.write(f"#ifndef {define_name}\n")
            self.defines_file_fd.write(
                f"#define {define_name} {self.attributes_data['defines'][define_name]}\n"
            )
            self.defines_file_fd.write("#endif\n")

        self.defines_file_fd.write("\n")
        current_syscall_number = 0
        for syscall_name in self.attributes_data["syscall_numbers"]:
            self.defines_file_fd.write(f"#define {syscall_name} {current_syscall_number}\n")
            current_syscall_number += 1

        for mod in self.priv_modes_enabled:
            self.defines_file_fd.write(f"#define {mod.upper()}_MODE_ENABLED 1\n")

    def generate_getter_and_setter_methods_for_field(
        self,
        c_struct,
        field_name,
        field_size_in_bytes,
        field_offset_in_struct,
    ):
        self.defines_file_fd.write(
            f"#define {c_struct.upper()}_{field_name.upper()}_OFFSET {field_offset_in_struct}\n"
        )

        self.defines_file_fd.write(
            f"#define GET_{c_struct.upper()}_{field_name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.LOAD, field_size_in_bytes)}   dest_reg, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp);\n"
        )
        self.defines_file_fd.write(
            f"#define SET_{c_struct.upper()}_{field_name.upper()}(dest_reg) {get_memop_of_size(MemoryOp.STORE, field_size_in_bytes)}   dest_reg, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp);\n\n"
        )

        modes = ListUtils.intersection(["smode", "mmode"], self.priv_modes_enabled)
        for mode in modes:
            self.assembly_file_fd.write(f'.section .jumpstart.cpu.text.{mode}, "ax"\n')
            getter_method = f"get_{c_struct}_{field_name}_from_{mode}"
            self.assembly_file_fd.write(f".global {getter_method}\n")
            self.assembly_file_fd.write(f"{getter_method}:\n")
            self.assembly_file_fd.write(f"    GET_{c_struct.upper()}_{field_name.upper()}(a0)\n")
            self.assembly_file_fd.write("    ret\n\n")

            self.assembly_file_fd.write(f".global set_{c_struct}_{field_name}_from_{mode}\n")
            self.assembly_file_fd.write(f"set_{c_struct}_{field_name}_from_{mode}:\n")
            self.assembly_file_fd.write(f"    SET_{c_struct.upper()}_{field_name.upper()}(a0)\n")
            self.assembly_file_fd.write("    ret\n\n")

    def generate_thread_attributes_setup_code(self):
        modes = ListUtils.intersection(["smode", "mmode"], self.priv_modes_enabled)
        mode_encodings = {"smode": "PRV_S", "mmode": "PRV_M"}
        for mode in modes:
            self.assembly_file_fd.write(f'.section .jumpstart.cpu.text.{mode}.init, "ax"\n')
            self.assembly_file_fd.write("# Inputs:\n")
            self.assembly_file_fd.write("#   a0: cpu id\n")
            self.assembly_file_fd.write("#   a1: physical cpu id\n")
            self.assembly_file_fd.write(f".global setup_thread_attributes_from_{mode}\n")
            self.assembly_file_fd.write(f"setup_thread_attributes_from_{mode}:\n")
            self.assembly_file_fd.write("  li t1, MAX_NUM_CPUS_SUPPORTED\n")
            self.assembly_file_fd.write(f"  bgeu a0, t1, jumpstart_{mode}_fail\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li  t2, THREAD_ATTRIBUTES_STRUCT_SIZE_IN_BYTES\n")
            self.assembly_file_fd.write("  mul t2, a0, t2\n")
            self.assembly_file_fd.write("  la  t1, thread_attributes_region\n")
            self.assembly_file_fd.write("  add tp, t1, t2\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_CPU_ID(a0)\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_PHYSICAL_CPU_ID(a1)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li t0, TRAP_OVERRIDE_ATTRIBUTES_STRUCT_SIZE_IN_BYTES\n")
            self.assembly_file_fd.write("  mul t0, a0, t0\n")
            self.assembly_file_fd.write("  la t1, trap_override_attributes_region\n")
            self.assembly_file_fd.write("  add t0, t1, t0\n")
            self.assembly_file_fd.write(
                "  SET_THREAD_ATTRIBUTES_TRAP_OVERRIDE_STRUCT_ADDRESS(t0)\n"
            )
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write(
                "  li t0, REG_CONTEXT_SAVE_REGION_SIZE_IN_BYTES * MAX_NUM_CONTEXT_SAVES\n"
            )
            self.assembly_file_fd.write("  mul t0, a0, t0\n")
            self.assembly_file_fd.write("\n")
            if "mmode" in modes:
                self.assembly_file_fd.write("  la t1, mmode_reg_context_save_region\n")
                self.assembly_file_fd.write("  add t1, t1, t0\n")
                self.assembly_file_fd.write("  la t2, mmode_reg_context_save_region_end\n")
                self.assembly_file_fd.write(f"  bgeu t1, t2, jumpstart_{mode}_fail\n")
                self.assembly_file_fd.write(
                    "  SET_THREAD_ATTRIBUTES_MMODE_REG_CONTEXT_SAVE_REGION_ADDRESS(t1)\n"
                )
                self.assembly_file_fd.write("  li t1, MAX_NUM_CONTEXT_SAVES\n")
                self.assembly_file_fd.write(
                    "  SET_THREAD_ATTRIBUTES_NUM_CONTEXT_SAVES_REMAINING_IN_MMODE(t1)\n"
                )
                self.assembly_file_fd.write("\n")

                self.assembly_file_fd.write("  csrr t1, marchid\n")
                self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_MARCHID(t1)\n")
                self.assembly_file_fd.write("  csrr t1, mimpid\n")
                self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_MIMPID(t1)\n")
                self.assembly_file_fd.write("\n")

            if "smode" in modes:
                self.assembly_file_fd.write("  la t1, smode_reg_context_save_region\n")
                self.assembly_file_fd.write("  add t1, t1, t0\n")
                self.assembly_file_fd.write("  la t2, smode_reg_context_save_region_end\n")
                self.assembly_file_fd.write(f"  bgeu t1, t2, jumpstart_{mode}_fail\n")
                self.assembly_file_fd.write(
                    "  SET_THREAD_ATTRIBUTES_SMODE_REG_CONTEXT_SAVE_REGION_ADDRESS(t1)\n"
                )

            self.assembly_file_fd.write("  li t1, MAX_NUM_CONTEXT_SAVES\n")
            self.assembly_file_fd.write(
                "  SET_THREAD_ATTRIBUTES_NUM_CONTEXT_SAVES_REMAINING_IN_SMODE(t1)\n"
            )
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li  t0, 0\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_SMODE_SETUP_DONE(t0)\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_VSMODE_SETUP_DONE(t0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_CURRENT_V_BIT(t0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write(f"  li  t0, {mode_encodings[mode]}\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_CURRENT_MODE(t0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  li  t0, THREAD_ATTRIBUTES_BOOKEND_MAGIC_NUMBER_VALUE\n")
            self.assembly_file_fd.write("  SET_THREAD_ATTRIBUTES_BOOKEND_MAGIC_NUMBER(t0)\n")
            self.assembly_file_fd.write("\n")
            self.assembly_file_fd.write("  ret\n")

    def generate_reg_context_save_restore_code(self):
        assert (
            self.attributes_data["reg_context_to_save_across_exceptions"]["temp_register"]
            not in self.attributes_data["reg_context_to_save_across_exceptions"]["registers"][
                "gprs"
            ]
        )

        num_registers = 0
        for reg_type in self.attributes_data["reg_context_to_save_across_exceptions"]["registers"]:
            reg_names = self.attributes_data["reg_context_to_save_across_exceptions"]["registers"][
                reg_type
            ]
            for reg_name in reg_names:
                self.defines_file_fd.write(
                    f"#define {reg_name.upper()}_OFFSET_IN_SAVE_REGION ({num_registers} * 8)\n"
                )
                num_registers += 1

        temp_reg_name = self.attributes_data["reg_context_to_save_across_exceptions"][
            "temp_register"
        ]

        self.defines_file_fd.write(
            f"\n#define REG_CONTEXT_SAVE_REGION_SIZE_IN_BYTES ({num_registers} * 8)\n"
        )
        self.defines_file_fd.write(
            f"\n#define MAX_NUM_CONTEXT_SAVES {self.attributes_data['reg_context_to_save_across_exceptions']['max_num_context_saves']}\n"
        )

        self.defines_file_fd.write("\n#define SAVE_ALL_GPRS   ;")
        for gpr_name in self.attributes_data["reg_context_to_save_across_exceptions"]["registers"][
            "gprs"
        ]:
            self.defines_file_fd.write(
                f"\\\n  sd {gpr_name}, {gpr_name.upper()}_OFFSET_IN_SAVE_REGION({temp_reg_name})   ;"
            )
        self.defines_file_fd.write("\n\n")

        self.defines_file_fd.write("\n#define RESTORE_ALL_GPRS   ;")
        for gpr_name in self.attributes_data["reg_context_to_save_across_exceptions"]["registers"][
            "gprs"
        ]:
            self.defines_file_fd.write(
                f"\\\n  ld {gpr_name}, {gpr_name.upper()}_OFFSET_IN_SAVE_REGION({temp_reg_name})   ;"
            )
        self.defines_file_fd.write("\n\n")

        self.assembly_file_fd.write('\n\n.section .jumpstart.cpu.data.privileged, "aw"\n')
        modes = ListUtils.intersection(["mmode", "smode"], self.priv_modes_enabled)
        self.assembly_file_fd.write(
            f"\n# {modes} context saved registers:\n# {self.attributes_data['reg_context_to_save_across_exceptions']['registers']}\n"
        )
        for mode in modes:
            self.assembly_file_fd.write(f".global {mode}_reg_context_save_region\n")
            self.assembly_file_fd.write(f"{mode}_reg_context_save_region:\n")
            for i in range(self.attributes_data["max_num_cpus_supported"]):
                self.assembly_file_fd.write(
                    f"  # {mode} context save area for cpu {i}'s {num_registers} registers. {self.attributes_data['reg_context_to_save_across_exceptions']['max_num_context_saves']} nested contexts supported.\n"
                )
                for i in range(
                    self.attributes_data["reg_context_to_save_across_exceptions"][
                        "max_num_context_saves"
                    ]
                ):
                    f"  # Context {i}\n"
                    self.assembly_file_fd.write(f"  .zero {num_registers * 8}\n\n")
            self.assembly_file_fd.write(f".global {mode}_reg_context_save_region_end\n")
            self.assembly_file_fd.write(f"{mode}_reg_context_save_region_end:\n\n")


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--jumpstart_source_attributes_yaml",
        help="YAML containing the jumpstart attributes.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--priv_modes_enabled",
        help=".",
        required=True,
        nargs="+",
        default=None,
    )
    parser.add_argument(
        "--defines_file", help="Header file containing the defines.", required=True, type=str
    )
    parser.add_argument(
        "--data_structures_file",
        help="Header file containing the c structures.",
        required=True,
        type=str,
    )
    parser.add_argument(
        "--assembly_file", help="Assembly file containing functions.", required=True, type=str
    )
    parser.add_argument(
        "-v", "--verbose", help="Verbose output.", action="store_true", default=False
    )
    args = parser.parse_args()

    if args.verbose:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.DEBUG)
    else:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s", level=log.INFO)

    source_generator = JumpStartGeneratedSource(
        args.jumpstart_source_attributes_yaml,
        args.defines_file,
        args.data_structures_file,
        args.assembly_file,
        args.priv_modes_enabled,
    )

    source_generator.generate()


if __name__ == "__main__":
    main()
