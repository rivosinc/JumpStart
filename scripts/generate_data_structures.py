#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 Rivos Inc.
# SPDX-FileCopyrightText: Copyright (c) 2022 by Rivos Inc.
#
# SPDX-License-Identifier: LicenseRef-Rivos-Internal-Only

import argparse
from enum import Enum
import logging as log
import os

import yaml


class MemoryOp(Enum):
    LOAD = 1,
    STORE = 2


def get_memop_of_size(memory_op_type, size_in_bytes):
    if memory_op_type == MemoryOp.LOAD:
        op = 'l'
    elif memory_op_type == MemoryOp.STORE:
        op = 's'
    else:
        raise Exception(f'Invalid memory op type: {memory_op_type}')

    if size_in_bytes == 1:
        return op + 'b'
    elif size_in_bytes == 2:
        return op + 'h'
    elif size_in_bytes == 4:
        return op + 'w'
    elif size_in_bytes == 8:
        return op + 'd'
    else:
        raise Exception(f'Invalid size: {size_in_bytes} bytes')


def generate_data_structures(attributes_yaml, defines_file,
                             data_structures_file, assembly_file):
    log.debug(f'Generating data structures files from {attributes_yaml}')

    attributes_data = None
    with open(attributes_yaml, "r") as f:
        attributes_data = yaml.safe_load(f)
        f.close()

    defines_file_fd = open(defines_file, "w")
    data_structures_file_fd = open(data_structures_file, "w")
    assembly_file_fd = open(assembly_file, "w")

    defines_file_fd.write(
        f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
    )
    defines_file_fd.write("#pragma once\n\n")
    data_structures_file_fd.write(
        f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
    )
    data_structures_file_fd.write("#pragma once\n\n")

    assembly_file_fd.write(
        f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
    )
    assembly_file_fd.write(".section .text\n\n")

    thread_attribute_fields = attributes_data['thread_attributes'][
        'fields_and_sizes']
    data_structures_file_fd.write("#include <inttypes.h>\n\n")
    data_structures_file_fd.write("struct thread_attributes {\n")
    current_offset = 0
    for field_name in thread_attribute_fields:
        attribute_size_in_bytes = thread_attribute_fields[field_name]
        data_structures_file_fd.write(
            f"    uint{attribute_size_in_bytes * 8}_t {field_name};\n")
        # Take care of the padding that the compiler will add.
        while (current_offset % attribute_size_in_bytes) != 0:
            current_offset += 1
        assembly_file_fd.write(
            f"#define THREAD_ATTRIBUTES_{field_name.upper()}_OFFSET {current_offset}\n\n"
        )
        assembly_file_fd.write(f'.section .text.jumpstart\n')
        assembly_file_fd.write(f'.global get_thread_{field_name}\n')
        assembly_file_fd.write(f'get_thread_{field_name}:\n')
        assembly_file_fd.write(
            f'    {get_memop_of_size(MemoryOp.LOAD, attribute_size_in_bytes)}   a0, THREAD_ATTRIBUTES_{field_name.upper()}_OFFSET(tp)\n'
        )
        assembly_file_fd.write(f'    ret\n\n')

        assembly_file_fd.write(f'.global set_thread_{field_name}\n')
        assembly_file_fd.write(f'set_thread_{field_name}:\n')
        assembly_file_fd.write(
            f'    {get_memop_of_size(MemoryOp.STORE, attribute_size_in_bytes)}   a0, THREAD_ATTRIBUTES_{field_name.upper()}_OFFSET(tp)\n'
        )
        assembly_file_fd.write(f'    ret\n\n')

        assembly_file_fd.write(f'.section .text.jumpstart.machine\n')
        assembly_file_fd.write(
            f'.global get_thread_{field_name}_in_machine_mode\n')
        assembly_file_fd.write(f'get_thread_{field_name}_in_machine_mode:\n')
        assembly_file_fd.write(
            f'    {get_memop_of_size(MemoryOp.LOAD, attribute_size_in_bytes)}   a0, THREAD_ATTRIBUTES_{field_name.upper()}_OFFSET(tp)\n'
        )
        assembly_file_fd.write(f'    ret\n\n')

        assembly_file_fd.write(
            f'.global set_thread_{field_name}_in_machine_mode\n')
        assembly_file_fd.write(f'set_thread_{field_name}_in_machine_mode:\n')
        assembly_file_fd.write(
            f'    {get_memop_of_size(MemoryOp.STORE, attribute_size_in_bytes)}   a0, THREAD_ATTRIBUTES_{field_name.upper()}_OFFSET(tp)\n'
        )
        assembly_file_fd.write(f'    ret\n\n')

        current_offset += attribute_size_in_bytes

    data_structures_file_fd.write("};\n\n")

    data_structures_file_fd.write("struct trap_override_attributes {\n")
    current_offset = 0
    for mode in attributes_data['trap_override_attributes']:
        data_structures_file_fd.write(
            f"    uint64_t {mode}[{attributes_data['trap_override_attributes'][mode]}];\n"
        )
        defines_file_fd.write(
            f"#define NUM_{mode.upper()} {attributes_data['trap_override_attributes'][mode]}\n"
        )
        current_offset += attributes_data['trap_override_attributes'][mode] * 8
    data_structures_file_fd.write("};\n\n")
    defines_file_fd.write(
        f"#define TRAP_ATTRIBUTES_STRUCT_SIZE_IN_BYTES {current_offset}\n\n")
    defines_file_fd.write("\n")

    for field_name in thread_attribute_fields:
        # Add the gettrs to jumpstart_functions.h so that they are
        # user visible.
        # data_structures_file_fd.write(
        #     f'uint{thread_attribute_fields[field_name] * 8}_t get_{field_name}(void);\n'
        # )
        data_structures_file_fd.write(
            f'void set_{field_name}(uint{thread_attribute_fields[field_name] * 8}_t value);\n'
        )

    # Align the end of the struct to 8 bytes.
    while (current_offset % 8) != 0:
        current_offset += 1
    defines_file_fd.write(
        f"#define THREAD_ATTRIBUTES_STRUCT_SIZE_IN_BYTES {current_offset}\n\n")
    defines_file_fd.write(
        f"#define THREAD_ATTRIBUTES_BOOKEND_MAGIC_NUMBER_VALUE 0x{attributes_data['thread_attributes']['bookend_magic_number_value']:08x}\n\n"
    )

    for define_name in attributes_data['defines']:
        defines_file_fd.write(
            f"#define {define_name} {attributes_data['defines'][define_name]}\n"
        )

    defines_file_fd.write("\n")
    current_syscall_number = 0
    for syscall_name in attributes_data['syscall_numbers']:
        defines_file_fd.write(
            f"#define {syscall_name} {current_syscall_number}\n")

    defines_file_fd.close()
    data_structures_file_fd.close()
    assembly_file_fd.close()


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '--attributes_yaml',
        help=f'YAML containing the attributes of the data structures.',
        required=True,
        type=str)
    parser.add_argument('--defines_file',
                        help=f'Header file containing the defines.',
                        required=True,
                        type=str)
    parser.add_argument('--data_structures_file',
                        help=f'Header file containing the c structures.',
                        required=True,
                        type=str)
    parser.add_argument('--assembly_file',
                        help=f'Assembly file containing functions.',
                        required=True,
                        type=str)
    parser.add_argument('-v',
                        '--verbose',
                        help='Verbose output.',
                        action='store_true',
                        default=False)
    args = parser.parse_args()

    if args.verbose:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s",
                        level=log.DEBUG)
    else:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s",
                        level=log.INFO)

    generate_data_structures(args.attributes_yaml, args.defines_file,
                             args.data_structures_file, args.assembly_file)


if __name__ == '__main__':
    main()
