#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 Rivos Inc.
# SPDX-FileCopyrightText: Copyright (c) 2022 by Rivos Inc.
#
# SPDX-License-Identifier: LicenseRef-Rivos-Internal-Only

import argparse
from enum import Enum
import logging as log
import os

import yaml


class MemoryOp(Enum):
    LOAD = 1,
    STORE = 2


def get_memop_of_size(memory_op_type, size_in_bytes):
    if memory_op_type == MemoryOp.LOAD:
        op = 'l'
    elif memory_op_type == MemoryOp.STORE:
        op = 's'
    else:
        raise Exception(f'Invalid memory op type: {memory_op_type}')

    if size_in_bytes == 1:
        return op + 'b'
    elif size_in_bytes == 2:
        return op + 'h'
    elif size_in_bytes == 4:
        return op + 'w'
    elif size_in_bytes == 8:
        return op + 'd'
    else:
        raise Exception(f'Invalid size: {size_in_bytes} bytes')


field_type_to_size_in_bytes = {
    'uint8_t': 1,
    'uint16_t': 2,
    'uint32_t': 4,
    'uint64_t': 8,
}


def generate_getter_and_setter_methods_for_field(assembly_file_fd, c_struct,
                                                 field_name,
                                                 field_size_in_bytes):
    assembly_file_fd.write(f'.section .jumpstart.text.supervisor, "ax"\n')
    getter_method = f'get_{c_struct}_{field_name}'
    assembly_file_fd.write(f'.global {getter_method}\n')
    assembly_file_fd.write(f'{getter_method}:\n')
    assembly_file_fd.write(
        f'    {get_memop_of_size(MemoryOp.LOAD, field_size_in_bytes)}   a0, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp)\n'
    )
    assembly_file_fd.write(f'    ret\n\n')

    assembly_file_fd.write(f'.global set_{c_struct}_{field_name}\n')
    assembly_file_fd.write(f'set_{c_struct}_{field_name}:\n')
    assembly_file_fd.write(
        f'    {get_memop_of_size(MemoryOp.STORE, field_size_in_bytes)}   a0, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp)\n'
    )
    assembly_file_fd.write(f'    ret\n\n')

    assembly_file_fd.write(f'.section .jumpstart.text.machine, "ax"\n')
    getter_method = f'get_{c_struct}_{field_name}_in_machine_mode'
    assembly_file_fd.write(f'.global {getter_method}\n')
    assembly_file_fd.write(f'{getter_method}:\n')
    assembly_file_fd.write(
        f'    {get_memop_of_size(MemoryOp.LOAD, field_size_in_bytes)}   a0, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp)\n'
    )
    assembly_file_fd.write(f'    ret\n\n')

    assembly_file_fd.write(
        f'.global set_{c_struct}_{field_name}_in_machine_mode\n')
    assembly_file_fd.write(f'set_{c_struct}_{field_name}_in_machine_mode:\n')
    assembly_file_fd.write(
        f'    {get_memop_of_size(MemoryOp.STORE, field_size_in_bytes)}   a0, {c_struct.upper()}_{field_name.upper()}_OFFSET(tp)\n'
    )
    assembly_file_fd.write(f'    ret\n\n')


def generate_data_structures(attributes_yaml, defines_file,
                             data_structures_file, assembly_file):
    log.debug(f'Generating data structures files from {attributes_yaml}')

    attributes_data = None
    with open(attributes_yaml, "r") as f:
        attributes_data = yaml.safe_load(f)
        f.close()

    defines_file_fd = open(defines_file, "w")
    data_structures_file_fd = open(data_structures_file, "w")
    assembly_file_fd = open(assembly_file, "w")

    defines_file_fd.write(
        f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
    )
    defines_file_fd.write("#pragma once\n\n")
    data_structures_file_fd.write(
        f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
    )
    data_structures_file_fd.write("#pragma once\n\n")

    assembly_file_fd.write(
        f"// This file is generated by {os.path.basename(__file__)}. Do not edit.\n\n"
    )

    defines_file_fd.write(
        f"#define MAX_NUM_CPUS_SUPPORTED {attributes_data['max_num_cpus_supported']}\n\n"
    )

    data_structures_file_fd.write("#include <inttypes.h>\n\n")

    total_size_of_c_structs = 0

    for c_struct in attributes_data['c_structs']:
        assembly_file_fd.write('.section .jumpstart.text.supervisor, "ax"\n\n')

        c_struct_fields = attributes_data['c_structs'][c_struct]['fields']
        current_offset = 0

        data_structures_file_fd.write(f"struct {c_struct} {{\n")
        for field_name in c_struct_fields:

            num_field_elements = 1
            if len(c_struct_fields[field_name].split(",")) > 1:
                field_type = c_struct_fields[field_name].split(",")[0]
                num_field_elements = int(
                    c_struct_fields[field_name].split(",")[1])
                defines_file_fd.write(
                    f"#define NUM_{field_name.upper()} {num_field_elements}\n")
            else:
                field_type = c_struct_fields[field_name]

            field_size_in_bytes = field_type_to_size_in_bytes[field_type]
            if num_field_elements > 1:
                data_structures_file_fd.write(
                    f"    {field_type} {field_name}[{num_field_elements}];\n")
            else:
                data_structures_file_fd.write(
                    f"    {field_type} {field_name};\n")

            # Take care of the padding that the compiler will add.
            while (current_offset % field_size_in_bytes) != 0:
                current_offset += 1

            if c_struct == "thread_attributes":
                assembly_file_fd.write(
                    f"#define {c_struct.upper()}_{field_name.upper()}_OFFSET {current_offset}\n\n"
                )
                generate_getter_and_setter_methods_for_field(
                    assembly_file_fd, c_struct, field_name,
                    field_size_in_bytes)

            current_offset += field_size_in_bytes * num_field_elements

        data_structures_file_fd.write("};\n\n")

        # Align the end of the struct to 8 bytes.
        while (current_offset % 8) != 0:
            current_offset += 1
        defines_file_fd.write(
            f"#define {c_struct.upper()}_STRUCT_SIZE_IN_BYTES {current_offset}\n\n"
        )

        assembly_file_fd.write(
            f'.section .jumpstart.data.privileged, "aw"\n\n')
        assembly_file_fd.write(f'.global {c_struct}_region\n')
        assembly_file_fd.write(f'{c_struct}_region:\n')
        assembly_file_fd.write(f".rep {current_offset}\n")
        assembly_file_fd.write(f'  .byte 0x00\n')
        assembly_file_fd.write(f'.endr\n')
        assembly_file_fd.write(f'.global {c_struct}_region_end\n')
        assembly_file_fd.write(f'{c_struct}_region_end:\n\n')

        total_size_of_c_structs += current_offset

    if total_size_of_c_structs * attributes_data['max_num_cpus_supported'] > (
            attributes_data['jumpstart_data_page_counts']
        ['num_pages_for_c_structs'] * 4096):
        log.error(
            f"Total size of C structs ({total_size_of_c_structs}) exceeds maximum size allocated for C structs {attributes_data['jumpstart_data_page_counts']['num_pages_for_c_structs'] * 4096}"
        )
        sys.exit(1)

    assembly_file_fd.write(f'.section .jumpstart.data.privileged, "aw"\n')
    assembly_file_fd.write(f'.align 12\n')
    assembly_file_fd.write(f'.global privileged_stack_top\n')
    assembly_file_fd.write(f'privileged_stack_top:\n')
    assembly_file_fd.write(
        f".rep {attributes_data['jumpstart_data_page_counts']['num_pages_for_privileged_stack'] * 4096}\n"
    )
    assembly_file_fd.write(f'.byte 0x00\n')
    assembly_file_fd.write(f'  .endr\n')
    assembly_file_fd.write(f'.global privileged_stack_bottom\n')
    assembly_file_fd.write(f'privileged_stack_bottom:\n\n')

    for define_name in attributes_data['defines']:
        defines_file_fd.write(
            f"#define {define_name} {attributes_data['defines'][define_name]}\n"
        )

    defines_file_fd.write("\n")
    current_syscall_number = 0
    for syscall_name in attributes_data['syscall_numbers']:
        defines_file_fd.write(
            f"#define {syscall_name} {current_syscall_number}\n")
        current_syscall_number += 1

    defines_file_fd.close()
    data_structures_file_fd.close()
    assembly_file_fd.close()


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '--attributes_yaml',
        help=f'YAML containing the attributes of the data structures.',
        required=True,
        type=str)
    parser.add_argument('--defines_file',
                        help=f'Header file containing the defines.',
                        required=True,
                        type=str)
    parser.add_argument('--data_structures_file',
                        help=f'Header file containing the c structures.',
                        required=True,
                        type=str)
    parser.add_argument('--assembly_file',
                        help=f'Assembly file containing functions.',
                        required=True,
                        type=str)
    parser.add_argument('-v',
                        '--verbose',
                        help='Verbose output.',
                        action='store_true',
                        default=False)
    args = parser.parse_args()

    if args.verbose:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s",
                        level=log.DEBUG)
    else:
        log.basicConfig(format="%(levelname)s: [%(threadName)s]: %(message)s",
                        level=log.INFO)

    generate_data_structures(args.attributes_yaml, args.defines_file,
                             args.data_structures_file, args.assembly_file)


if __name__ == '__main__':
    main()
